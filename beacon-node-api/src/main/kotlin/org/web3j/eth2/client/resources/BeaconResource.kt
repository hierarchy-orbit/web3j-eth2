/**
 * Eth2 Beacon Node API
 * API specification for the beacon node, which enables users to query and participate in Ethereum 2.0 phase 0 beacon chain.
 *
 * OpenAPI spec version: v0.12.2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package org.web3j.eth2.client.resources

import org.web3j.eth2.client.infrastructure.ApiClient
import org.web3j.eth2.client.infrastructure.ClientError
import org.web3j.eth2.client.infrastructure.ClientException
import org.web3j.eth2.client.infrastructure.MultiValueMap
import org.web3j.eth2.client.infrastructure.RequestConfig
import org.web3j.eth2.client.infrastructure.RequestMethod
import org.web3j.eth2.client.infrastructure.ResponseType
import org.web3j.eth2.client.infrastructure.ServerError
import org.web3j.eth2.client.infrastructure.ServerException
import org.web3j.eth2.client.infrastructure.Success
import org.web3j.eth2.client.infrastructure.toMultiValue
import org.web3j.eth2.client.models.Body
import org.web3j.eth2.client.models.Body1
import org.web3j.eth2.client.models.Body2
import org.web3j.eth2.client.models.Body3
import org.web3j.eth2.client.models.Body4
import org.web3j.eth2.client.models.Epoch
import org.web3j.eth2.client.models.GetBlockAttestationsResponse
import org.web3j.eth2.client.models.GetBlockHeaderResponse
import org.web3j.eth2.client.models.GetBlockHeadersResponse
import org.web3j.eth2.client.models.GetBlockResponse
import org.web3j.eth2.client.models.GetBlockRootResponse
import org.web3j.eth2.client.models.GetEpochCommitteesResponse
import org.web3j.eth2.client.models.GetGenesisResponse
import org.web3j.eth2.client.models.GetPoolAttestationsResponse
import org.web3j.eth2.client.models.GetPoolAttesterSlashingsResponse
import org.web3j.eth2.client.models.GetPoolProposerSlashingsResponse
import org.web3j.eth2.client.models.GetPoolVoluntaryExitsResponse
import org.web3j.eth2.client.models.GetStateFinalityCheckpointsResponse
import org.web3j.eth2.client.models.GetStateForkResponse
import org.web3j.eth2.client.models.GetStateRootResponse
import org.web3j.eth2.client.models.GetStateValidatorBalancesResponse
import org.web3j.eth2.client.models.GetStateValidatorResponse
import org.web3j.eth2.client.models.GetStateValidatorsResponse
import org.web3j.eth2.client.models.Index
import org.web3j.eth2.client.models.ParentRoot
import org.web3j.eth2.client.models.Slot
import org.web3j.eth2.client.models.Slot1

class BeaconResource(basePath: String = "{server_url}") : ApiClient(basePath) {

    /**
     * Get block
     * Retrieves block details for given block id.
     * @param blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @return GetBlockResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getBlock(blockId: String): GetBlockResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/blocks/{block_id}".replace("{" + "block_id" + "}", "$blockId")
        )
        val response = request<GetBlockResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetBlockResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get block attestations
     * Retrieves attestation included in requested block.
     * @param blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @return GetBlockAttestationsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getBlockAttestations(blockId: String): GetBlockAttestationsResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/blocks/{block_id}/attestations".replace("{" + "block_id" + "}", "$blockId")
        )
        val response = request<GetBlockAttestationsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetBlockAttestationsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get block header
     * Retrieves block header for given block id.
     * @param blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @return GetBlockHeaderResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getBlockHeader(blockId: String): GetBlockHeaderResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/headers/{block_id}".replace("{" + "block_id" + "}", "$blockId")
        )
        val response = request<GetBlockHeaderResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetBlockHeaderResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get block headers
     * Retrieves block headers matching given query. By default it will fetch current head slot blocks.
     * @param slot  (optional)
     * @param parentRoot  (optional)
     * @return GetBlockHeadersResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getBlockHeaders(slot: Slot1? = null, parentRoot: ParentRoot? = null): GetBlockHeadersResponse {
        val localVariableQuery: MultiValueMap = mapOf("slot" to listOf("$slot"), "parent_root" to listOf("$parentRoot"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/headers", query = localVariableQuery
        )
        val response = request<GetBlockHeadersResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetBlockHeadersResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get block root
     * Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader
     * @param blockId Block identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded blockRoot with 0x prefix\\&gt;.
     * @return GetBlockRootResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getBlockRoot(blockId: String): GetBlockRootResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/blocks/{block_id}/root".replace("{" + "block_id" + "}", "$blockId")
        )
        val response = request<GetBlockRootResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetBlockRootResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get all committees for epoch
     * Retrieves the committees for the given state at the given epoch.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param epoch Epoch for which to calculate committees. Defaults to beacon state epoch.
     * @param index Committee index (optional)
     * @param slot  (optional)
     * @return GetEpochCommitteesResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getEpochCommittees(stateId: String, epoch: Epoch, index: Index? = null, slot: Slot? = null): GetEpochCommitteesResponse {
        val localVariableQuery: MultiValueMap = mapOf("index" to listOf("$index"), "slot" to listOf("$slot"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/committees/{epoch}".replace("{" + "state_id" + "}", "$stateId").replace("{" + "epoch" + "}", "$epoch"), query = localVariableQuery
        )
        val response = request<GetEpochCommitteesResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetEpochCommitteesResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Retrieve details of the chain&#x27;s genesis.
     * Retrieve details of the chain&#x27;s genesis which can be used to identify chain.
     * @return GetGenesisResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getGenesis(): GetGenesisResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/genesis"
        )
        val response = request<GetGenesisResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetGenesisResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get Attestations from operations pool
     * Retrieves attestations known by the node but not necessarily incorporated into any block
     * @param slot  (optional)
     * @param committeeIndex  (optional)
     * @return GetPoolAttestationsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getPoolAttestations(slot: String? = null, committeeIndex: String? = null): GetPoolAttestationsResponse {
        val localVariableQuery: MultiValueMap = mapOf("slot" to listOf("$slot"), "committee_index" to listOf("$committeeIndex"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/pool/attestations", query = localVariableQuery
        )
        val response = request<GetPoolAttestationsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetPoolAttestationsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get AttesterSlashings from operations pool
     * Retrieves attester slashings known by the node but not necessarily incorporated into any block
     * @return GetPoolAttesterSlashingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getPoolAttesterSlashings(): GetPoolAttesterSlashingsResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/pool/attester_slashings"
        )
        val response = request<GetPoolAttesterSlashingsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetPoolAttesterSlashingsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get ProposerSlashings from operations pool
     * Retrieves proposer slashings known by the node but not necessarily incorporated into any block
     * @return GetPoolProposerSlashingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getPoolProposerSlashings(): GetPoolProposerSlashingsResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/pool/proposer_slashings"
        )
        val response = request<GetPoolProposerSlashingsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetPoolProposerSlashingsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get SignedVoluntaryExit from operations pool
     * Retrieves voluntary exits known by the node but not necessarily incorporated into any block
     * @return GetPoolVoluntaryExitsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getPoolVoluntaryExits(): GetPoolVoluntaryExitsResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/pool/voluntary_exits"
        )
        val response = request<GetPoolVoluntaryExitsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetPoolVoluntaryExitsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get state finality checkpoints
     * Returns finality checkpoints for state with given &#x27;stateId&#x27;. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @return GetStateFinalityCheckpointsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateFinalityCheckpoints(stateId: String): GetStateFinalityCheckpointsResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/finality_checkpoints".replace("{" + "state_id" + "}", "$stateId")
        )
        val response = request<GetStateFinalityCheckpointsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateFinalityCheckpointsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get Fork object for requested state
     * Returns [Fork](https://github.com/ethereum/eth2.0-specs/blob/v0.11.1/specs/phase0/beacon-chain.md#fork) object for state with given &#x27;stateId&#x27;.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @return GetStateForkResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateFork(stateId: String): GetStateForkResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/fork".replace("{" + "state_id" + "}", "$stateId")
        )
        val response = request<GetStateForkResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateForkResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get state SSZ HashTreeRoot
     * Calculates HashTreeRoot for state with given &#x27;stateId&#x27;. If stateId is root, same value will be returned.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @return GetStateRootResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateRoot(stateId: String): GetStateRootResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/root".replace("{" + "state_id" + "}", "$stateId")
        )
        val response = request<GetStateRootResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateRootResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get validator from state by id
     * Returns validator specified by state and id or public key along with status and balance.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param validatorId Either hex encoded public key (with 0x prefix) or validator index
     * @return GetStateValidatorResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateValidator(stateId: String, validatorId: String): GetStateValidatorResponse {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/validators/{validator_id}".replace("{" + "state_id" + "}", "$stateId").replace("{" + "validator_id" + "}", "$validatorId")
        )
        val response = request<GetStateValidatorResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateValidatorResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get validator balances from state
     * Returns filterable list of validator balances.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param id Either hex encoded public key (with 0x prefix) or validator index (optional)
     * @return GetStateValidatorBalancesResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateValidatorBalances(stateId: String, id: Array<String>): GetStateValidatorBalancesResponse {
        val localVariableQuery: MultiValueMap = mapOf("id" to toMultiValue(id.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/validator_balances".replace("{" + "state_id" + "}", "$stateId"), query = localVariableQuery
        )
        val response = request<GetStateValidatorBalancesResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateValidatorBalancesResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Get validators from state
     * Returns filterable list of validators with their balance, status and index.
     * @param stateId State identifier. Can be one of: \&quot;head\&quot; (canonical head in node&#x27;s view), \&quot;genesis\&quot;, \&quot;finalized\&quot;, \&quot;justified\&quot;, \\&lt;slot\\&gt;, \\&lt;hex encoded stateRoot with 0x prefix\\&gt;.
     * @param id Either hex encoded public key (with 0x prefix) or validator index (optional)
     * @param status [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ) (optional)
     * @return GetStateValidatorsResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun getStateValidators(stateId: String, id: Array<String>, status: Array<Any>): GetStateValidatorsResponse {
        val localVariableQuery: MultiValueMap = mapOf("id" to toMultiValue(id.toList(), "multi"), "status" to toMultiValue(status.toList(), "multi"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/eth/v1/beacon/states/{state_id}/validators".replace("{" + "state_id" + "}", "$stateId"), query = localVariableQuery
        )
        val response = request<GetStateValidatorsResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as GetStateValidatorsResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Publish a signed block.
     * Instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be included in the beacon chain. The beacon node is not required to validate the signed &#x60;BeaconBlock&#x60;, and a successful response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the new block into its state, and therefore validate the block internally, however blocks which fail the validation are still broadcast but a different status code is returned (202)
     * @param body The &#x60;SignedBeaconBlock&#x60; object composed of &#x60;BeaconBlock&#x60; object (produced by beacon node) and validator signature.
     * @return void
     */
    fun publishBlock(body: Body): Unit {
        val localVariableBody: Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/eth/v1/beacon/blocks"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Submit Attestation object to node
     * Submits Attestation object to node. If attestation passes all validation constraints, node MUST publish attestation on appropriate subnet.
     * @param body
     * @return void
     */
    fun submitPoolAttestations(body: Body1): Unit {
        val localVariableBody: Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/eth/v1/beacon/pool/attestations"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Submit AttesterSlashing object to node&#x27;s pool
     * Submits AttesterSlashing object to node&#x27;s pool and if passes validation node MUST broadcast it to network.
     * @param body
     * @return void
     */
    fun submitPoolAttesterSlashings(body: Body2): Unit {
        val localVariableBody: Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/eth/v1/beacon/pool/attester_slashings"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Submit ProposerSlashing object to node&#x27;s pool
     * Submits ProposerSlashing object to node&#x27;s pool and if passes validation  node MUST broadcast it to network.
     * @param body
     * @return void
     */
    fun submitPoolProposerSlashings(body: Body3): Unit {
        val localVariableBody: Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/eth/v1/beacon/pool/proposer_slashings"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }

    /**
     * Submit SignedVoluntaryExit object to node&#x27;s pool
     * Submits SignedVoluntaryExit object to node&#x27;s pool and if passes validation node MUST broadcast it to network.
     * @param body
     * @return void
     */
    fun submitPoolVoluntaryExit(body: Body4): Unit {
        val localVariableBody: Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/eth/v1/beacon/pool/voluntary_exits"
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String
                    ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message
                    ?: "Server error")
        }
    }
}
